'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const assert = require('assert');

class TopologicalSort {

    constructor(nodes) {
        this._nodes = new Map();
        this._addNodes(nodes);
    }

    addNode(key, node) {
        return this._addNode(key, node);
    }

    addNodes(nodes) {
        this._addNodes(nodes);
    }

    addEdge(fromKey, toKey) {
        assert(this._nodes.has(fromKey), `Source node with ${ fromKey } key should exist`);
        assert(this._nodes.has(toKey), `Target node with ${ toKey } key should exist`);

        const sourceNode = this._nodes.get(fromKey);
        const targetNode = this._nodes.get(toKey);

        assert.strictEqual(sourceNode !== undefined, true, `Source node with key ${ fromKey } doesn't exist`);
        assert.strictEqual(targetNode !== undefined, true, `Target node with key ${ toKey } doesn't exist`);
        assert.strictEqual(sourceNode.children.has(toKey), false, `Source node ${ fromKey } already has an adge to target node ${ toKey }`);

        sourceNode.children.set(toKey, targetNode);
    }

    sort() {
        this._visitedNodes = new Set();
        this._sortedKeysStack = [];
        const output = new Map();

        for (const _ref of this._nodes) {
            var _ref2 = _slicedToArray(_ref, 1);

            const key = _ref2[0];

            this._exploreNode(key, []);
        }

        for (let i = this._sortedKeysStack.length - 1; i >= 0; i--) {
            output.set(this._sortedKeysStack[i], this._nodes.get(this._sortedKeysStack[i]).node);
        }

        return output;
    }

    _exploreNode(nodeKey, explorePath) {
        const newExplorePath = [].concat(_toConsumableArray(explorePath), [nodeKey]);

        // we should check circular dependencies starting from node 2
        if (explorePath.length) {
            assert(!(explorePath.indexOf(nodeKey) !== -1), `Node ${ nodeKey } forms circular dependency: ${ newExplorePath.join(' -> ') }`);
        }

        const node = this._nodes.get(nodeKey);
        if (this._visitedNodes.has(node)) {
            return;
        }

        // mark node as visited so that it and its children
        // won't be explored next time
        this._visitedNodes.add(node);

        for (const _ref3 of node.children) {
            var _ref4 = _slicedToArray(_ref3, 1);

            const childNodeKey = _ref4[0];

            this._exploreNode(childNodeKey, newExplorePath);
        }

        this._sortedKeysStack.push(nodeKey);
    }

    _addNode(key, node) {
        assert.strictEqual(this._nodes.has(key), false, `Node ${ key } already exists`);

        this._nodes.set(key, {
            node,
            children: new Map()
        });

        return this;
    }

    _addNodes(nodes) {
        const nodesFlat = [].concat(_toConsumableArray(nodes));

        for (let i = nodes.size - 1; i >= 0; i--) {
            var _nodesFlat$i = _slicedToArray(nodesFlat[i], 2);

            const key = _nodesFlat$i[0];
            const node = _nodesFlat$i[1];

            this._addNode(key, node);
        }
    }

}

module.exports = TopologicalSort;
